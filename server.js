const fs = require('fs');
const path = require('path');
const LRU = require('lru-cache');
const express = require('express');
const favicon = require('serve-favicon');
const compression = require('compression');
const microcache = require('route-cache');
const resolve = (file) => path.resolve(__dirname, file);
const { createBundleRenderer } = require('vue-server-renderer');

/* 生产环境 */
const isProd = process.env.NODE_ENV === 'production';
const useMicroCache = process.env.MICRO_CACHE !== 'false';
/* 版本信息 */
const serverInfo =
	`express/${require('express/package.json').version} ` +
	`vue-server-renderer/${require('vue-server-renderer/package.json').version} `;

const app = express();

/**
 * 生成渲染器
 * @param {json} bundle 服务端json文件
 * @param {object} options 配置
 * @param {string} options.template 模板内容
 * @param {json} options.clientManifest 客户端json文件
 */
function createRenderer(bundle, options) {
	return createBundleRenderer(
		bundle,
		Object.assign(options, {
			// 组件级别缓存
			cache: LRU({
				max: 1000,
				maxAge: 1000 * 60 * 15,
			}),
			// this is only needed when vue-server-renderer is npm-linked
			basedir: resolve('./dist'),
			// recommended for performance
			runInNewContext: false,
		})
	);
}

let renderer; /* 渲染器 */
let readyPromise;
const templatePath = resolve('./src/index.template.html');

if (isProd) {
	// In production: create server renderer using template and built server bundle.
	// The server bundle is generated by vue-ssr-webpack-plugin.
	const template = fs.readFileSync(templatePath, 'utf-8');
	const bundle = require('./dist/vue-ssr-server-bundle.json');
	// The client manifest are optional, but it allows the renderer
	// to automatically infer preload/prefetch links and directly add <script>
	// tags for any async chunks used during render, avoiding waterfall requests.
	const clientManifest = require('./dist/vue-ssr-client-manifest.json');
	renderer = createRenderer(bundle, {
		template,
		clientManifest,
	});
} else {
	// In development: setup the dev server with watch and hot-reload,
	// and create a new renderer on bundle / index template update.
	readyPromise = require('./build/setup-dev-server')(app, templatePath, (bundle, options) => {
		renderer = createRenderer(bundle, options);
	});
}

const serve = (path, cache) =>
	express.static(resolve(path), {
		maxAge: cache && isProd ? 1000 * 60 * 60 * 24 * 30 : 0,
	});

app.use(compression({ threshold: 0 }));
app.use(favicon('./public/imgs/logo.png'));
app.use('/dist', serve('./dist', true));
app.use('/public', serve('./public', true));
app.use('/manifest.json', serve('./manifest.json', true));

// 如果内容不是用户特定 (user-specific)
//（即对于相同的 URL，总是为所有用户渲染相同的内容），
// 我们可以利用名为 micro-caching 的缓存策略，
// 来大幅度提高应用程序处理高流量的能力。
app.use(microcache.cacheSeconds(1, (req) => useMicroCache && req.originalUrl));

function render(req, res) {
	const s = Date.now();

	res.setHeader('Content-Type', 'text/html');
	res.setHeader('Server', serverInfo);

	const handleError = (err) => {
		if (err.url) {
			res.redirect(err.url);
		} else if (err.code === 404) {
			res.status(404).send('404 | Page Not Found');
		} else {
			// Render Error Page or Redirect
			res.status(500).send('500 | Internal Server Error');
			console.error(`error during render : ${req.url}`);
			console.error(err.stack);
		}
	};

	const context = {
		title: '标题', // default title
		meta: `
      <meta name="theme-color" content="#4285f4">
    `,
		url: req.url,
	};

	// 这里无需传入一个应用程序，因为在执行 bundle 时已经自动创建过。
	// 现在我们的服务器与应用程序已经解耦！
	renderer.renderToString(context, (err, html) => {
		if (err) {
			return handleError(err);
		}

		res.send(html);
		if (true) {
			console.log(`响应: ${new Date().toISOString().replace(/[a-z]/gi, ' ')} ${req.url} | ${Date.now() - s}ms`);
		}
	});
}

// 在服务器处理函数中，调用 render 函数
app.get(
	'*',
	isProd
		? render
		: (req, res) => {
				readyPromise.then(() => render(req, res));
		  }
);

app.set('port', process.env.PORT || 9999);
let hostname = '0.0.0.0';
app.listen(app.get('port'), hostname, () => {
	console.log(`Server running at http://${hostname}:${app.get('port')}`);
});

process.on('unhandledRejection', (e) => {
	console.log(e);
});
